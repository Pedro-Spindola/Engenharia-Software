--- Código Limpo ---
package com.spindola; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.List; import java.util.stream.Collectors; public class Main { public static String getCleanedCode(String inputPathString) throws IOException { Path inputPath = Paths.get(inputPathString); String content = Files.readString(inputPath); String withoutBlockComments = content.replaceAll("(?s)/\\*.*?\\*/", ""); String withoutLineComments = withoutBlockComments.replaceAll(" String cleanedCode = withoutLineComments.lines() .map(String::trim) .filter(line -> !line.isEmpty()) .collect(Collectors.joining(" ")); return cleanedCode; } public static void main(String[] args) { String inputFile = "atividade_01\\src\\main\\java\\com\\spindola\\Main.java"; String outputFile = "tokens_e_simbolos.txt"; StringBuilder outputBuffer = new StringBuilder(); try { String cleanSource = getCleanedCode(inputFile); outputBuffer.append("--- Código Limpo ---\n").append(cleanSource).append("\n--------------------\n"); SymbolTable symbolTable = new SymbolTable(); Lexer lexer = new Lexer(cleanSource, symbolTable); List<Token> tokens = lexer.scanTokens(); outputBuffer.append("\n--- Sequência de Tokens (Léxico) ---\n"); tokens.forEach(token -> { String output = ""; TokenType type = token.getType(); String lexeme = token.getLexeme(); if (type == TokenType.ID) { output = symbolTable.getIdentifierEntry(lexeme); } else if (type == TokenType.NU) { output = symbolTable.getNumberEntry(lexeme); } else if (type == TokenType.FR) { output = symbolTable.getPhraseEntry(lexeme); } else if (type == TokenType.OL) { output = "[ol, " + lexeme + "]"; } else if (type == TokenType.OM) { output = "[om, " + lexeme + "]"; } else { String typeName = type.name().toLowerCase().replace("kw_", "").replace("simb_", ""); if (type == TokenType.SIMB_ATRIBUICAO) typeName = ":"; if (type == TokenType.SIMB_PONTO_VIRGULA) typeName = ";"; if (type == TokenType.SIMB_PARENTESES_ABRE) typeName = "("; if (type == TokenType.SIMB_PARENTESES_FECHA) typeName = ")"; if (type == TokenType.EOF) { output = "[EOF, ]"; } else if (type == TokenType.ERROR) { output = "[ERROR, " + lexeme + "]"; } else { output = "[" + typeName + ", ]"; } } outputBuffer.append(output).append(" "); }); outputBuffer.append("\n"); outputBuffer.append(symbolTable.getFormattedTables()); Path outputPath = Paths.get(outputFile); Files.writeString(outputPath, outputBuffer.toString()); System.out.println("Processamento concluído com sucesso!"); System.out.println("Saída gravada em: " + outputFile); } catch (IOException e) { System.err.println("Erro ao processar o arquivo: " + e.getMessage()); } } }
--------------------

--- Sequência de Tokens (Léxico) ---
[id, 1] [id, 2] [ERROR, .] [id, 3] [;, ] [id, 4] [id, 5] [ERROR, .] [id, 6] [ERROR, .] [id, 7] [;, ] [id, 4] [id, 5] [ERROR, .] [id, 8] [ERROR, .] [id, 9] [ERROR, .] [id, 10] [;, ] [id, 4] [id, 5] [ERROR, .] [id, 8] [ERROR, .] [id, 9] [ERROR, .] [id, 11] [;, ] [id, 4] [id, 5] [ERROR, .] [id, 8] [ERROR, .] [id, 9] [ERROR, .] [id, 12] [;, ] [id, 4] [id, 5] [ERROR, .] [id, 13] [ERROR, .] [id, 14] [;, ] [id, 4] [id, 5] [ERROR, .] [id, 13] [ERROR, .] [id, 15] [ERROR, .] [id, 16] [;, ] [id, 17] [id, 18] [id, 19] [ERROR, {] [id, 17] [id, 20] [id, 21] [id, 22] [(, ] [id, 21] [id, 23] [), ] [id, 24] [id, 7] [ERROR, {] [id, 11] [id, 25] [ol, =] [id, 12] [ERROR, .] [id, 26] [(, ] [id, 23] [), ] [;, ] [id, 21] [id, 27] [ol, =] [id, 10] [ERROR, .] [id, 28] [(, ] [id, 25] [), ] [;, ] [id, 21] [id, 29] [ol, =] [id, 27] [ERROR, .] [id, 30] [(, ] [fr,"(?s)/\\*.*?\\*/"] [ERROR, ,] [fr,""] [), ] [;, ] [id, 21] [id, 31] [ol, =] [id, 29] [ERROR, .] [id, 30] [(, ] [fr," String cleanedCode = withoutLineComments.lines() .map(String::trim) .filter(line -> !line.isEmpty()) .collect(Collectors.joining("] [fr,")); return cleanedCode; } public static void main(String[] args) { String inputFile = "] [id, 32] [ERROR, \] [ERROR, \] [id, 33] [ERROR, \] [ERROR, \] [id, 34] [ERROR, \] [ERROR, \] [id, 5] [ERROR, \] [ERROR, \] [id, 2] [ERROR, \] [ERROR, \] [id, 3] [ERROR, \] [ERROR, \] [id, 19] [ERROR, .] [id, 5] [fr,"; String outputFile = "] [id, 35] [ERROR, .] [id, 36] [fr,"; StringBuilder outputBuffer = new StringBuilder(); try { String cleanSource = getCleanedCode(inputFile); outputBuffer.append("] [om, -] [om, -] [om, -] [id, 37] [ERROR, ó] [id, 38] [id, 39] [om, -] [om, -] [om, -] [ERROR, \] [id, 40] [fr,").append(cleanSource).append("] [ERROR, \] [id, 40] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [om, -] [ERROR, \] [id, 40] [fr,"); SymbolTable symbolTable = new SymbolTable(); Lexer lexer = new Lexer(cleanSource, symbolTable); List<Token> tokens = lexer.scanTokens(); outputBuffer.append("] [ERROR, \] [id, 40] [om, -] [om, -] [om, -] [id, 41] [ERROR, ê] [id, 42] [id, 43] [id, 44] [(, ] [id, 45] [ERROR, é] [id, 46] [), ] [om, -] [om, -] [om, -] [ERROR, \] [id, 40] [fr,"); tokens.forEach(token -> { String output = "] [fr,"; TokenType type = token.getType(); String lexeme = token.getLexeme(); if (type == TokenType.ID) { output = symbolTable.getIdentifierEntry(lexeme); } else if (type == TokenType.NU) { output = symbolTable.getNumberEntry(lexeme); } else if (type == TokenType.FR) { output = symbolTable.getPhraseEntry(lexeme); } else if (type == TokenType.OL) { output = "] [ERROR, [] [id, 47] [ERROR, ,] [fr," + lexeme + "] [ERROR, ]] [fr,"; } else if (type == TokenType.OM) { output = "] [ERROR, [] [id, 48] [ERROR, ,] [fr," + lexeme + "] [ERROR, ]] [fr,"; } else { String typeName = type.name().toLowerCase().replace("] [id, 49] [fr,", "] [fr,").replace("] [id, 50] [fr,", "] [fr,"); if (type == TokenType.SIMB_ATRIBUICAO) typeName = "] [:, ] [fr,"; if (type == TokenType.SIMB_PONTO_VIRGULA) typeName = "] [;, ] [fr,"; if (type == TokenType.SIMB_PARENTESES_ABRE) typeName = "] [(, ] [fr,"; if (type == TokenType.SIMB_PARENTESES_FECHA) typeName = "] [), ] [fr,"; if (type == TokenType.EOF) { output = "] [ERROR, [] [id, 51] [ERROR, ,] [ERROR, ]] [fr,"; } else if (type == TokenType.ERROR) { output = "] [ERROR, [] [id, 52] [ERROR, ,] [fr," + lexeme + "] [ERROR, ]] [fr,"; } else { output = "] [ERROR, [] [fr," + typeName + "] [ERROR, ,] [ERROR, ]] [fr,"; } } outputBuffer.append(output).append("] [fr,"); }); outputBuffer.append("] [ERROR, \] [id, 40] [fr,"); outputBuffer.append(symbolTable.getFormattedTables()); Path outputPath = Paths.get(outputFile); Files.writeString(outputPath, outputBuffer.toString()); System.out.println("] [id, 53] [id, 54] [ERROR, í] [id, 55] [id, 2] [id, 56] [ol, !] [fr,"); System.out.println("] [id, 57] [ERROR, í] [id, 58] [id, 59] [id, 60] [:, ] [fr," + outputFile); } catch (IOException e) { System.err.println("] [id, 61] [id, 62] [id, 63] [id, 64] [id, 65] [:, ] [ERROR, " + e.getMessage()); } } }] [EOF, ] 

--- Tabela de Símbolos ---
IDs: {com=2, de=43, getCleanedCode=22, digo=38, gravada=59, main=34, String=21, do=55, Limpo=39, java=5, nio=8, arquivo=65, List=14, ERROR=52, inputPathString=23, Tokens=44, Collectors=16, package=1, static=20, atividade_01=32, xico=46, io=6, em=60, throws=24, withoutBlockComments=29, ao=62, Sequ=41, inputPath=25, util=13, tokens_e_simbolos=35, ncia=42, C=37, import=4, spindola=3, L=45, replaceAll=30, content=27, simb_=50, file=9, public=17, stream=15, conclu=54, get=26, Paths=12, Files=10, class=18, ol=47, EOF=51, withoutLineComments=31, om=48, processar=63, Path=11, src=33, readString=28, IOException=7, Erro=61, n=40, Sa=57, o=64, txt=36, kw_=49, Processamento=53, Main=19, sucesso=56, da=58}
Números: {}
Frases: {=2, ").replace("=43, "; if (type == TokenType.SIMB_PONTO_VIRGULA) typeName = "=45, (?s)/\\*.*?\\*/=1, ; } else { output = =22, " String cleanedCode = withoutLineComments.lines() .map(String::trim) .filter(line -> !line.isEmpty()) .collect(Collectors.joining("=31, "); }); outputBuffer.append("=53, ; StringBuilder outputBuffer = new StringBuilder(); try { String cleanSource = getCleanedCode(inputFile); outputBuffer.append(=6, ").append(cleanSource).append("=35, "; } else { output = "=50, ; if (type == TokenType.SIMB_PARENTESES_ABRE) typeName = =18,  String cleanedCode = withoutLineComments.lines() .map(String::trim) .filter(line -> !line.isEmpty()) .collect(Collectors.joining(=3, ); }); outputBuffer.append(=25, ; TokenType type = token.getType(); String lexeme = token.getLexeme(); if (type == TokenType.ID) { output = symbolTable.getIdentifierEntry(lexeme); } else if (type == TokenType.NU) { output = symbolTable.getNumberEntry(lexeme); } else if (type == TokenType.FR) { output = symbolTable.getPhraseEntry(lexeme); } else if (type == TokenType.OL) { output = =10, ; if (type == TokenType.EOF) { output = =20, "; TokenType type = token.getType(); String lexeme = token.getLexeme(); if (type == TokenType.ID) { output = symbolTable.getIdentifierEntry(lexeme); } else if (type == TokenType.NU) { output = symbolTable.getNumberEntry(lexeme); } else if (type == TokenType.FR) { output = symbolTable.getPhraseEntry(lexeme); } else if (type == TokenType.OL) { output = "=38, ); System.out.println(=27, "; } else { String typeName = type.name().toLowerCase().replace("=41, "; if (type == TokenType.SIMB_PARENTESES_ABRE) typeName = "=46,  + typeName + =23, ; if (type == TokenType.SIMB_PONTO_VIRGULA) typeName = =17, ; if (type == TokenType.SIMB_PARENTESES_FECHA) typeName = =19, "; } else if (type == TokenType.OM) { output = "=40, "; if (type == TokenType.EOF) { output = "=48, ; String outputFile = =5, "; StringBuilder outputBuffer = new StringBuilder(); try { String cleanSource = getCleanedCode(inputFile); outputBuffer.append("=34, ""=30, ); outputBuffer.append(symbolTable.getFormattedTables()); Path outputPath = Paths.get(outputFile); Files.writeString(outputPath, outputBuffer.toString()); System.out.println(=26, ); tokens.forEach(token -> { String output = =9, ); SymbolTable symbolTable = new SymbolTable(); Lexer lexer = new Lexer(cleanSource, symbolTable); List<Token> tokens = lexer.scanTokens(); outputBuffer.append(=8, "); if (type == TokenType.SIMB_ATRIBUICAO) typeName = "=44, "; } } outputBuffer.append(output).append("=52,  + lexeme + =11, ")); return cleanedCode; } public static void main(String[] args) { String inputFile = "=32, " + typeName + "=51, "); System.out.println("=55, ; } else if (type == TokenType.OM) { output = =12, ", "=42, "; if (type == TokenType.SIMB_PARENTESES_FECHA) typeName = "=47, "(?s)/\\*.*?\\*/"=29, "); tokens.forEach(token -> { String output = "=37, " + lexeme + "=39, )); return cleanedCode; } public static void main(String[] args) { String inputFile = =4, ); if (type == TokenType.SIMB_ATRIBUICAO) typeName = =16, ; } else { String typeName = type.name().toLowerCase().replace(=13, " + outputFile); } catch (IOException e) { System.err.println("=56, "); SymbolTable symbolTable = new SymbolTable(); Lexer lexer = new Lexer(cleanSource, symbolTable); List<Token> tokens = lexer.scanTokens(); outputBuffer.append("=36, "; String outputFile = "=33, ; } } outputBuffer.append(output).append(=24, "; } else if (type == TokenType.ERROR) { output = "=49, ).append(cleanSource).append(=7, ).replace(=15, , =14, ; } else if (type == TokenType.ERROR) { output = =21,  + outputFile); } catch (IOException e) { System.err.println(=28, "); outputBuffer.append(symbolTable.getFormattedTables()); Path outputPath = Paths.get(outputFile); Files.writeString(outputPath, outputBuffer.toString()); System.out.println("=54}
--------------------------
